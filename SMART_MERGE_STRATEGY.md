# 智能问题合并策略

## 核心原则
**优先问题（是什么+原理）不参与去重，只去重其他维度的问题。**

## 实现逻辑

### 1. 识别优先问题
满足以下任一条件的问题被视为优先问题：
- 包含【优先】标记
- 同时包含"是什么"类关键词和"原理"类关键词

**"是什么"类关键词**：
- 是什么、展示了什么、代表什么、什么内容、什么含义

**"原理"类关键词**：
- 原理、逻辑、机制、流程

### 2. 合并策略

当检测到两个相似section时：

```python
优先问题池 = []
其他问题池 = []

# 从两个section提取问题
for each sub_question:
    if is_priority_question(question):
        加入优先问题池（去重阈值0.8）
    else:
        加入其他问题池（去重阈值0.7）

# 最终合并
合并后的问题 = 优先问题池 + 其他问题池
```

### 3. 去重阈值

- **优先问题**：相似度>0.8才视为重复（严格保护）
- **其他问题**：相似度>0.7即视为重复（较宽松）

## 预期效果

### 原来（简单替换）
```
Section A: [优先问题1, mechanism1, critique1]
Section B: [优先问题2, mechanism2, critique2]
→ 结果: Section B（丢失了Section A的问题）
```

### 现在（智能合并）
```
Section A: [优先问题1, mechanism1, critique1]
Section B: [优先问题2, mechanism2, critique2]
→ 结果: [优先问题1, 优先问题2, mechanism1, mechanism2去重, critique1, critique2去重]
```

## 示例输出

```
🔄 合并: '3.1.1 Fig 1 任务范式' (保留优先问题，去重其他问题)
  - 保留优先问题 × 2
  - 去重mechanism问题: 3→2
  - 去重critique问题: 2→1
  - 最终: 5个子问题
```

## 优势

1. ✅ **基础描述完整**：所有优先问题都保留
2. ✅ **避免冗余**：重复的深度分析问题被去重
3. ✅ **保持多样性**：来自不同批次的独特问题都保留
4. ✅ **顺序合理**：优先问题始终在最前面
